# 中断与中断处理

如何让处理器和这些外部设备能协同工作，且不会降低机器的整体性能呢？轮询（polling）可能会是一种解决方法。它可以让内核定期对设备的状态进行查询，并做出相应的处理。不过这种会让内核做不少无用功。更好的方法是提供一种机制，让硬件需要的时候再向内核发出信号。这就是中断机制。

## 中断

中断本身是一种特殊的电信号，由硬件设备发向处理器。硬件设备生成中断的时候并不考虑与处理器的时钟同步——换句话说就是中断随时产生，内核随时可能因为新到来的中断而被打断。

中断是一种电信号，由硬件设备生成，并直接送入中断控制器的输入引脚中——中断控制器是个简单的电子芯片，其作用是将多路中断管线，采用复用技术只通过一个与处理器相连接的管线与处理器通信。

不同设备对应的中断不同，而每个中断都有一个唯一的数字标志。这些中断值通常被称为中断请求（IRQ）线。每个IRQ线都会关联一个数值量。但并非所有的中断号都是这样严格定义的。例如，对于PCI总线上的设备而言，中断是动态分配的。重点在于特定的中断总是与特定的设备相关联，并且内核要知道这些信息。

> 异常
>
> 异常和中断不同，它在产生时必须考虑与处理器时钟同步。实际上，异常也常常称为同步中断。在处理器执行到由于编程失误而导致的错误指令（如被0除）的时候，必须靠内核来处理的时候，处理器就会产生一个异常。处理异常和处理中断的方式类似。

## 中断处理程序

在响应一个特定中断的时候，内核会执行一个函数，该函数叫做中断处理程序或中断服务例程。一个设备的中断处理程序是它设备驱动程序的一部分——设备驱动程序是用于对设备进行管理的内核代码。

在Linux中，中断处理程序就是普普通通的C函数，只不过这些函数必须按照特定的类型声明，以便内核能够以标准的方式传递处理程序的信息。中断处理程序运行在称为中断上下文的特殊上下文中，也被称作原子上下文，该上下文的执行代码不可阻塞。

中断随时发生，必须保证中断处理程序能快速执行，这样才能尽可能快地回复中断代码的执行。

## 上半部和下半部的对比

又想中断处理程序运行得快，又想中断处理程序完成的任务量多。鉴于两个目的之间存在此消彼长的矛盾关系，所以我们一般把中断处理切为两个部分。中断处理程序是上半部（top half）——接收到一个中断，它就会立即开始执行，但只做有严格时限的工作，例如对接受的中断进行应答或复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部（bottom half）去。此后，在合适的时机，下半部会被开中断执行。

以网卡为例。当网卡收到内核的数据包时，需要立即通知内核数据包到了。内核通过执行网卡已注册的中断处理程序来做出应答。

中断开始执行，内核需要快速拷贝网络数据包到系统内存，因为网卡上接收网络数据包的缓存大小固定，而且相比系统内存要小得多，所以上述拷贝动作一旦被延迟，必然造成缓存溢出。当数据包被拷贝到系统内存后，中断的任务算是完成了，这时它会将控制权交还给系统被中断前运行的程序。处理和操作数据包的其他工作在随后的下半部中进行。

## 注册中断处理程序

驱动程序可以通过 request_trq() 函数注册一个中断处理程序，被声明在`<linux/interrupt.h>`，并且激活给定的中断线，以处理中断。

```c
// 成功返回0，失败返回非0.最常见的错误是 -EBUSY，表示给定的中断线已经在使用（或者没有指定IRQF_SHARED）
int request_irq(unsigned int irq,
               irq_handler_t handler,
               unsigned long flags,
               const char *name,
               void *dev);
```

- 第一个参数irq表示要分配的中断号，对某些设备来说，如键盘，这个值是预先确定的。但对大多数设备来说，这个值要么可以通过探测获取，要么可以通过编程动态确定。

- 第二个参数handler是一个指针，指向处理这个中断的实际中断处理程序。

  ```c
  typedef irqreturn_t (*irq_handler_t)(int, void *);
  ```

  ### 中断处理程序标志

  

- 第三个参数flags可以为0，也可能是下面一个或多个标志的位掩码。定于在文件 `<linux/interrupt.h>`

  - IRQF_DISABLED——该标志被设置后，意味着内核在处理中断处理程序本身期间，要禁止所有的其他中断。多数中断处理程序是不会去设置该位的，因为禁止所有中断是一种野蛮行为。

  - IRQF_SAMPLE_RANDOM——此标志表明这个设备产生的中断对内核熵池（entropy pool）有贡献。内核熵池负责提供从各种随机时间中导出的真正的随机数。如果设置该标志，那么来自设备的中断间隔时间就会作为熵填充到熵池。如果你的设备以预知的速率产生中断，就不要设置这个标志。很多硬件产生中断的速率是不可预知的，所以都能成为一种较好的熵源。

  - IRQF_TIMER——特别为系统定时器的中断处理准备的。

  - IRQF_SHARED——表明可以在多个中断处理程序之间共享中断线。在同一个给定线上注册的每个处理程序必须指定这个标志；否则每个线上只能由一个处理程序。

- 第四个参数name是与中断相关的设备的ASCII文本表示。例如键盘中断对应的这个值是 keyboard。这些名字会被 /proc/irq 和 /proc/interrupts 文件使用，以便于用户通信
- 第五个参数dev用于共享中断线。当一个中断处理程序需要释放时，dev将提供唯一的标志信息（cookie），以便从共享中断线的诸多中断处理程序中删除指定的那一个。如果无须共享中断线，那么该值为NULL。如果中断线是被共享的，那么就必须传递唯一的信息（除非设备又旧又破且位于ISA总线上，那么就必须支持共享中断）。内核每次调用中断处理程序时，都会把这个指针传递给它。实践中往往会通过它传递驱动程序的设备结构：这个指针是唯一的，而且有可能在中断处理程序内被用到。

注意，**request_irq() 函数可能会睡眠**，因此不能在中断上下文或者其他不允许阻塞的代码中调用该函数。在注册的过程中，内核需要在 /proc/irq 文件中创建一个于中断对应的项。函数 proc_mkdir() 就是用来创建这个新的 procfs 项的。proc_mkdir() 通过调用 proc_create() 对这个新的procfs项设置，而**proc_create() 会调用 kmalloc()**请求分配内存，该函数是可睡眠的。

### 释放中断处理程序

卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线：

```c
void free_irq(unsigned int irq, void *dev);
```

如果指定的中断线（IRQ值）不是共享的，那么该函数删除处理程序的同时将禁用这条中断线。唯一的dev很重要，对于共享的中断线，需要一个唯一的信息区分其上面的多个处理程序，并让 free_irq() 仅删除指定的处理程序

## 编写中断处理程序

```c
static irqreturn_t intr_handler(int irq, void *dev);
```

中断处理程序的返回值是一个特殊类型：irqreturn_t。中断处理程序可能返回两个特殊的值：IRQ_NONE 和 IRQ_HANDLED。当中断处理程序检测到一个中断，但该中断对应的设备并不是在注册处理函数期间指定的产生源时，返回 IRQ_NONE。当中断处理程序被正确调用，且确实是它所对应的设备产生了中断时，返回IRQ_HANDLED。利用这些特殊值，内核可以直到设备发出的是否是一种虚假的中断。如果给定中断线上所有中断处理程序返回的都是IRQ_NONE，那么内核就可以检测到出了问题。irqreturn_t 实际上是一个 int 型。之所以使用这些特殊值是为了与早期的内核保持兼容。2.6之前的内核不支持这种类型，如果是2.4或更早的内核上使用这样的驱动程序，只需简单地将typedef irqreturn_t 改为void。中断处理程序通常标记为static，因为它从来不会被别的文件中的代码直接调用。

> 重入和中断处理程序
>
> Linux中断处理程序是无须重入的。当一个给定的中断处理程序正在执行时，相应的中断线在所有处理器上都会被屏蔽掉，以防同一个中断线接收另一个新的中断。同一个中断处理程序绝对不会被同时调用以处理嵌套的中断。

### 共享的中断处理程序

指定IRQF_SHARED标志以调用request_irq时，只有以下两种情况才可能成功：中断线当前未被注册，或者在该线上的所有已注册处理程序都制定了IRQF_SHARED。

内核接收到一个中断，将依次调用在该中断线上注册的每一个处理程序。因此，一个处理程序必须直到它是否该为这中断负责。如果与它相关的设备并没有产生中断，那么处理程序应该立即退出。这需要硬件设备提供状态寄存器，以便中断处理程序进行检查。

> 中断处理程序会先检查对应硬件设备的状态寄存器，是否是自己产生的中断，不是则退出。

## 中断上下文

进程上下文是一种内核所处的操作模式，此时内核代表进程执行——例如，执行系统调用或运行内核线程。在进程上下文中，可以通过current宏关联当前进程。因为进程是以进程上下文的形式连接到内核中的，因此进程上下文可以睡眠，也可以调用调度程序。

> “进程以进程上下文的形式连接到内核”是什么意思？？？我理解的进程上下文实际就是进程执行的代码位置，可能是指此时的内核可以看作是进程上下文的一部分；另一种理解是将 “进程上下文” 变为一个结构传入到内核中，”可以通过current宏关联“。无论哪一种，无论此时运行的代码是在进程代码中还是内核代码中，都是可以睡眠的。

中断上下文具有较为严格的时间限制，因为它打断了其他代码。正是因为这种异步执行的特性，所以所有的中断处理程序必须尽可能的迅速、简洁。

中断处理程序栈的设置是一个配置选项。曾经中断处理程序并不具有自己的栈。它们共享所中断进程的内核栈。内核栈的大小是两页，在32位体系结构上是8KB，在64位体系结构上是16KB。

在2.6版早期内核中，增加了一个选项，把栈的大小从两页减到一页，减轻了内存的压力。因为系统中每个进程原先都需要两页连续且不可换出的内核内存。为了应付栈大小的减少，中断处理程序拥有自己的栈，每个处理器一个，大小为一页。这个栈称为中断栈，尽管中断栈大小是原先共享栈的一般，但平均可用栈空间大得多，因为中断处理程序把这一整页占为己有。